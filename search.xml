<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[GDT结构体笔记]]></title>
      <url>%2F2017%2F01%2F12%2FGDT%E7%BB%93%E6%9E%84%E4%BD%93%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows消息队列和消息循环]]></title>
      <url>%2F2017%2F01%2F09%2FWindows-API%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[数据类型 UINT 表示C语言中的无符号整型unsigned int PSTR表示字符串指针 char* WPARAM 在16位时期的windows中表示unsigned short int,现在表示UINT LPARAM 表示long WndProc 函数的返回值LRESULT实际上就是long 入口函数WinMain被指定的WINAPI和Proc被指定的CALLBACK都表示的是_stdcall，表示Windows和用户应用程序之间发生函数呼叫的参数传递方式。 句柄是Windows API中大量使用的一种类型，比如HINSTANCE, HWND, HDC, HICON, HCUROR, HBRUSH。它们其实是一个32位的整数，代表某种特定的对象。据我所知这东西似乎也是单任务时期Windows的遗留产物，把同一个程序的不同实例进行标记，从而可以在它们之前进行内存上的继承。 消息消息就是一个整型值.如果你查看一下你的头文件的话(当你去调查API的工作机制的话,这是一个非常好的也是大多数人都有的习惯)你就发现下面这些东西:123#define WM_INITDIALOG 0x0110#define WM_COMMAND 0x0111#define WM_LBUTTONDOWN 0x0201 消息是用于底层这个层次上,窗口之间的通信.假如你希望窗口或是控件(其实也是一个特殊的窗口)做某个事情的话,你就发送给它一个消息. 假如有另一个窗口希望你做某个事情的话,它也送一个消息给你.假如有比如像用户敲击键盘,移动鼠标,点击按钮之类的事件发生的话,那么这些消息就由系统发送给那些受到影响的窗口.假如你的窗口是其中的一个的话,你就要处理这个消息,对这个消息做出相应的反应. 每个窗口消息都有两个参数,wParam和lParam.最初wParam是16位的,lParam是32位,但是在WIN32中,它们都是32位的.不是每条消息都用到了这些参数,而且不同的消息 对它们的使用是不同的.举个例子,WM_CLOSE消息就两个参数都没有用到,你可以把两个都忽略.WM_COMMAND消息就两个参数都用上了,wParam参数包含了两个值,一个是HIWORD(wParam),它是消息的通知码(如果可用的话),另一个是LOWORD(wParam),它是发送消息的控件或是菜单的标识符. lParam是发送消息的控件的HWND(HWND是一种数据类型,也就是窗口的句柄.控件的实质也是一个窗口,因此它也有句柄),当这个消息不是来自于一个控件或是窗口,lParam 的值就是NULL,.(比如当消息是由菜单产生时,lParam就是NULL) HIWORD()和 LOWORD()是由windows定义的宏,它们的作用分别是取得一个32位的值的高两个字节(高字)和低两个字节(低字) ,(相当于是将一个双字分别去和0XFFFF0000以及0X0000FFFF作与运算,再分别向右和向左作相应16位位移后得到的结果) 在WIN32中,一个字是16位,一个双字也就是32位了. 发送一个消息,你可以用函数PostMessage()或函数SendMessage(). 函数PostMessage()的作用是将消息送到消息队列中,然后立即返回.这意味着,一旦你调用了函数 PostMessage()后,那么这个消息有没有得到处理就不一定了.函数 SendMessage()是将消息直接发送给窗口,然后要一直等窗口对这个消息的处理完成了,这个函数才会返回了.假如我们想关闭一个窗口的话,我们可以发送给这个窗口一个WM_CLOSE的消息,比如像这样做:PostMessage(hwnd, WM_CLOSE, 0, 0),那么这个你去点击窗口上方的关闭按钮 的效果是一样的.请注意wParam和 lParam都是0.原因就正如我们已经谈到的那样,WM_CLOSE消息没有用到这两个参数 对话框一旦你开始使用对话框,为了和对话框进行通信,你就会需要发送消息给对话框上的控件.为了做到这一点,你要么用函数GetDlgItem()加上控件的标识符来获得控件的句柄,然后呢,再用函数SendMessage();要么你就用函数SendDlgItemMessage(),这个函数把以上两步结合起来了. 你给这个函数一个窗口的句柄以及子窗口(也就是这个窗口上的控件)的标识符,你就可以获取标识符所对应的子窗口的句柄,接下来就是给子窗口发送消息了.函数SendDlgItemMessage()以及类似的API比如GetDlgItemMessage()可以工作在所有的窗口上,不仅仅是对话框. 消息队列让我们假设当你在忙于处理WM_PAINT消息时,突然用户在键盘上敲了一串键.这会发生什么事情呢?你到底是应该停下你的画画,对键盘作出响应,还是对敲下的这些键置之不理呢?显然两种方式都是不合理的.因此我们有了消息队列.当消息被送入消息队列后,你一个个的对它们进行处理,处理一个消息,就移除一个消息.(当然先来的消息先得到处理)这样可以确保存你不会错过哪条消息.当你对某条消息进行处理时,其它消息就等待在队列中,直到你来处理它们. 消息循环12345while(GetMessage(&amp;Msg, NULL, 0, 0) &gt; 0)&#123; TranslateMessage(&amp;Msg); DispatchMessage(&amp;Msg);&#125; 消息循环调用函数GetMessage(),这个函数它会去察看你的消息队列.假如消息队列是空的(也就是没有任何消息),那么我们的程序就停在那里,等待消息的到来.当某一个导致消息被送到消息队列的事件发生时(举个例子,系统注册的鼠标点击,比如点击关闭按钮),函数GetMessage()就会返回一个正值,表明这里有一个需要得到处理的消息,而且这个消息的值被赋给了我们传递给函数GetMessage()的参数Msg,这个结构体中.如果这个消息是WM_QUIT,那么函数GetMessage()的返回值就是0.如果有错误产生的话,那么返回值就是负值.我们得到消息后(消息在结构体变量Msg中),接下来就可以把消息传递给函数TranslateMessage().这个函数对消息又多做了一步处理,它将虚拟键的消息翻译成字符消息.这一步事实上是可选的,但是如果没有这一步的话,某些事情就不会发生了.一旦这些做完以后,我们把消息传递给函数DispatchMessage(). 函数DispatchMessage()所做的事情就是检查消息是发送哪个窗口的,然后再去查看这个窗口的窗口过程.然后呢,它就会调用这个过程,将参数:窗口的句柄,消息以及wParam和lParam,送给窗口过程.在你的窗口过程中,你就会检查消息和它的参数,然后根据消息和它的参数,你就可以做你想做的事情了!你不用对所有的消息都进行处理,对于你不想亲自去处理的消息,你就调用函数DefWindowProc()就是了.它会为你对那些没有处理的消息做一些默认的处理.(一般情况下,这个函数其实什么也没有做,也就是相当于将你没有处理的消息忽略掉了,等于那些消息从没有产生过,只是从消息队列中过了一遍.)一旦你做完对消息的处理之后,你的窗口过程就返回了,函数DispatchMessage()也返回了.我们又回到了整个循环的的开始.对于WINDOWS程序,这里有一个非常重要的概念.那就是你的窗口过程不是由系统调用的,事实上是你自己通过调用函数DispatchMessage()间接地调用的. 假如你想自己来调用窗口过程的话(不通过函数DispatchMessage()),你可以把接受消息的窗口,它的窗口句柄作为参数传递给函数GetWindowLong()(函数GetWindowLong()通过设置最后一个参数为GWL_WNDPROC,可以获得窗口过程的地址),这样直接得到窗口的窗口过程,然后再直接执行这个窗口过程!12345while(GetMessage(&amp;Msg, NULL, 0, 0) &gt; 0)&#123; WNDPROC fWndProc = (WNDPROC)GetWindowLong(Msg.hwnd, GWL_WNDPROC); fWndProc(Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam);&#125; 我在前面的例程序中尝试了这种作法,而且它确实是可行的.但是这里有许多事情,比如Unicode/ANSI的转换,调用定时器返回等等就不行了,所以呢,你可以试一试,但是不要用在实际的应用中. 请注意,我们用函数GetWindowLong()获得和这个窗口相关的窗口过程.为什么不直接调用我们的WndProc()呢?是这样的,我们的消息循环负责我们程序中的所有的窗口,这些窗口包括了比如按钮,列表框之类,它们都有各自的窗口过程.因此我们要确定对不同的窗口我们调用的是相应的窗口过程.因为多个窗口都可以使用相同的窗口过程,第一个参数(窗口的句柄)就用于告诉窗口过程,消息是送给哪个窗口的. 正如你所看到的那样,你的应用程序花费了绝大多数的时间在消息循环中往往返返.你非常惬意地发送一条消息给运行得正开心的窗口处理.但是当你想你的窗口退出时,你该怎么做呢?因为我们用的是一个while()循环,假如函数GetMessage()的返回值是0(OK,0),这个循环就结束了.我们也就到达我们的WinMain()的终点了,从而退出程序.这些正是函数PostQuitMessage()完成的事情.它将WM_QUIT消息送到了队列中,和返回一个正值不同,函数GetMessage()填充了Msg结构体,然后返回一个0.在这里Msg结构体的成员wParam包含了你传递给函数PostQuitMessage()的值.你要么将这个值忽略掉,要么把它作为WinMain()的返回值.也就是这个过程终止时的退出码. 重要之处: 函数GetMessage()将会返回-1假如它遇到了错误的话.你要记住这一点,不然的话,在某些时候你就会被它拖住的….即使这个函数是定义成返回一个布尔值,它也可以返回除了真或假以外的其它值,因为BOOL布尔型被定义成UINT(无符号整型).下面是例程序代码,它看起来可以运行,但是在某些情况下不能正确处理. 123while(GetMessage(&amp;Msg, NULL, 0, 0))while(GetMessage(&amp;Msg, NULL, 0, 0) != 0)while(GetMessage(&amp;Msg, NULL, 0, 0) == TRUE) 上面的全是错的！ 你也许注意到了在整个教程中我用的都是第一个,正如我所提到的那样,只要函数GetMessage()的调用不失败的话(前提是你的所有代码都是正确的),它还是可以工作得很好.然而我有一点没有考虑到,那就是当你看到我写的这些文字的时候,你的代码可能在绝大多数的情况下都有错误.还有一点就是函数GetMessage()本身也可能在某些情况下调用失败 :) 我会全部检查一遍并且纠正这个错误,但是如果我漏掉了一些的话,就原谅我. while(GetMessage(&amp;Msg, NULL, 0, 0) &gt; 0) 上面这个就是对的.要取得相同效果的代码也应该总是这个样子的.我希望你现在对窗口的消息循环有了一个更好的理解,假如不是这样的话,不要灰心,不要害怕,一旦你使用它们一段时间后,所有的事情都会明白的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内存泄露与内存溢出]]></title>
      <url>%2F2017%2F01%2F06%2F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
      <content type="text"><![CDATA[内存泄露与内存溢出的区别 内存溢出（out of memory）比如申请一个integer， 但是赋值超过4个字节， 需要占用更多的内存才能存储， 这就是内存溢出。 相当于占用了未知多于的内存。 内存泄露(memory leak)值程序在申请内存后无法释放已申请的内存空间， 即该内存没有指向它的指针。 一个内存泄露的危害可以忽略不计， 最终程序运行时间越长， 占用存储空间越来越多，最终用尽全部存储空间，导致系统崩溃。(指的虚拟内存， 即swap区的大小决定) 多指heap区，堆内存一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。 memory leak 最终导致 out of memory（一个盘子最多装3个苹果， 你装4个，有一个掉地上（这就是溢出）比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. ） 内存泄露（new）, 可是使用完没有归还（delete），结果申请的那块内存自己无法访问（不知道地址），系统也无法分配该内存。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库笔记]]></title>
      <url>%2F2016%2F12%2F15%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[引言对SQL语法做一个简单的笔记。 WHERE &amp; GROUP BY &amp; ORDER BY &amp; HAVINGwhere 是条件语句比如：SELECT id FROM signin WHERE name=sher;GROUP BY是分组，比如 获取每个客户的工资总额SELECT name, SUM(salary) FROM company GROUP BY name; ORDER BY 排序HAVING 在GROUP BY 后 DRDER BY 前， 对分组后的结果按条件过滤SELECT * FROM company GROUP BY name HAVING count(name) &lt; 2; 注： limit 可以获取特定行数的数据。12345SELECT COUNT(*) FROM audience;SELECT update_time FROM signin WHERE audience_id=3;SELECT SUM(score)+SUM(extra_score) FROM log WHERE audience_id=3;SELECT COUNT(*) FROM log WHERE type=2;CREATE VIEW managelog AS SELECT audience.name,signin.grade,signin.score,signin.day_lines,signin.update_time FROM audience,signin WHERE signin.audience_id=audience._id ORDER BY signin.total_score DESC; 最后一条创建视图。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c#数据库解析]]></title>
      <url>%2F2016%2F11%2F26%2Fc-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[引言工作需要将数十万条文本数据解析存入Mysql数据库中，代码使用C#实现，存储效率还可以，以下是一些主要代码的说明。 c# 项目代码txtdataToMysql项目描述：解析文本文件，该文件使用爬虫爬下的数十万条数据，主要是图片以及图片关键字，图片信息使用&#39;,&#39;分隔，关键字使用 &#39; &#39;（一个空格）,关键字不允许重复。 分析需要创建的数据库该数据库为多对多，所以需要三张表，一张表为image_info，一张为image_keyword，一张为关系表img_and_key_relation。在这里并没有添加外键，加入外键后插入数据难度比较大，Mysql还没有具体学习过，关于主键与外键的关系，以及外键的作用等以后补充。以下为创建数据库的代码 12345create database emotion; use emotion; create table image_Keyword(keyword_id int(4) not null primary key,keyword varchar(40) not null);create table image_info(image_id int(4) not null primary key,id_other varchar(20) not null,id_self varchar(9) not null,image_url varchar(100) not null);create table img_and_key_relation(relation_id int(4) not null primary key auto_increment,keyword_id int(4) not null,image_id int(4) not null); 这里并没有将image_info与image_keyword的主键设为自动增加，为了插入img_and_key_relation表时能够获得其余两张表的键值，具体获得方法将在代码中讲解。 解析文本 代码使用c#写的所以可以使用按行读取文本，使用Split()方法将文本进行解析，对于文本解析专门设置了一个class TxtFilter，在该类中实现文本解析方法，在插入关键字时，使用Dictionary&lt;string, int&gt; keywordDic,将关键字存入字典中，字典的关键字为解析的关键字,使用字典因为要求键值唯一，这样在匹配关键字是可以方便，开始的时候并没有注意到Mysql数据库大小写不敏感，而c#的字典键值为大小写敏感的，所有在插入关键字是有些重复了，设置字典大小写不敏感需要如此创建字典Dictionary&lt;string, int&gt; keywordDic = new Dictionary&lt;string, int&gt;(StringComparer.OrdinalIgnoreCase);这样可以保证插入的关键字唯一。对判断关键字的唯一性使用hashset也是可以，但是不知道它能否无视大小写，所以还需要补充，hashset的时间复杂度为O(1),而Dictionary的时间复杂度为O(n)，当数据量比较大时查找速度比较快。Dictionary与hashset的区别再去字典使用key查找value,查找value的速度比较快，而hashset为一个集合，关于这两个的区别以后还会补充，目前只知道这些。 c#连接Mysql数据库12345678910private static string constr = @"Server=localhost;UserId=root;password=yourpassword;Database=databaseName"; public MySqlConnection sqlConnection() &#123; MySqlConnection conn = new MySqlConnection(constr); conn.Open(); string msg = conn.State.ToString(); return conn; &#125; public void sqlConnectionClose(MySqlConnection conn) &#123; conn.Close(); &#125; 这里创建了一个数据库类，在该类中实现以上两种方法，目的保护数据库账户密码，在这里并不需要，只是个人的一点想法，不知道对错 如何大批量插入数据到Mysql中这里参考了链接采用了事物处理的方法，具体的还需要进一步学习。主要是将插入语句放入到一个List&lt;string&gt;中，所以需要解析文本，生成插入语句，将所有的插入语句添加到一个列表中，为了检查插入语句的正确性，将所有的插入语句写入到一个txt文本中，方便检查。 txtFilter类分析解析的文本文件由一些特点，有些图片没有关键字，所以对于这些信息需要判断删除，并且解析关键字的时候有的关键字是空格，这些问题在开始的时候都没有考虑到。所以在原来的代码上添加了一些判定条件。为了检查方便将三张表的插入语句各自打印了出来，有些代码存在重复，可以优化一些，比如针对不同的操作设定操作码，使用switch case语句，选择不同的筛选方式。先写出关键的文本解析语句，将所有插入语句存入List&lt;string&gt;中，并且定义了将插入语句写入文本的函数，这样有利于查看插入语句是否存在问题。以下是主要函数代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public List&lt;string&gt; filterToSqlCommond2(string fileName)&#123; List&lt;string&gt; SQLStringList = new List&lt;string&gt;(); Data fileData = new Data(); Dictionary&lt;string, int&gt; keywordDic = new Dictionary&lt;string, int&gt;(StringComparer.OrdinalIgnoreCase); string sqlCommond=""; int numOfKeyword = 0; int numOfImage = 0; //如果使用HashSet判断关键字是否存在会更快一些，这里并没有用这种方法 //HashSet&lt;string&gt; keywordSet = new HashSet&lt;string&gt;(); StreamReader sr = new StreamReader(fileName); string strContent; while ((strContent = sr.ReadLine()) != null) &#123; string[] strArr = strContent.Split(','); fileData.id_other = strArr[0]; fileData.id_self = strArr[1]; fileData.image_url = strArr[3]; string insertImageCommond = ""; string insertKeyAndR = ""; string[] keyword = strArr[4].Split(' '); //numKeyword表示读取每一行获得的关键字个数 int numKeyword = keyword.Length; switch(numKeyword)&#123; case 1: if (!string.IsNullOrEmpty(keyword[0])) &#123; numOfImage += 1; insertImageCommond = string.Format(@"insert into image(image_id,id_other,id_self,image_url) values('&#123;0&#125;','&#123;1&#125;','&#123;2&#125;','&#123;3&#125;');", numOfImage, fileData.id_other, fileData.id_self, fileData.image_url); if (!keywordDic.Keys.Contains(keyword[0])) &#123; numOfKeyword += 1; keywordDic.Add(keyword[0], numOfKeyword); string.Format(@" insert into imagekeyword(keyword_id,keyword) value('&#123;0&#125;','&#123;1&#125;');insert into img_and_key_relation(keyword_id,image_id) values('&#123;2&#125;','&#123;3&#125;');", keywordDic[keyword[0]], keyword[0], keywordDic[keyword[0]], numOfImage); &#125; else &#123; int keyword_id = keywordDic[keyword[0]]; insertKeyAndR = insertKeyAndR + string.Format(@"insert into img_and_key_relation(keyword_id,image_id) values('&#123;0&#125;','&#123;1&#125;');", keyword_id, numOfImage); &#125; &#125; sqlCommond = insertImageCommond + insertKeyAndR; SQLStringList.Add(sqlCommond); break; default: numOfImage += 1; insertImageCommond = string.Format(@"insert into image(image_id,id_other,id_self,image_url) values('&#123;0&#125;','&#123;1&#125;','&#123;2&#125;','&#123;3&#125;');", numOfImage, fileData.id_other, fileData.id_self, fileData.image_url); for (int i = 0; i &lt; numKeyword; i++) &#123; if (!string.IsNullOrEmpty(keyword[i])) &#123; if (!keywordDic.Keys.Contains(keyword[i])) &#123; numOfKeyword += 1; keywordDic.Add(keyword[i], numOfKeyword); insertKeyAndR = insertKeyAndR + string.Format(@" insert into imagekeyword(keyword_id,keyword) value('&#123;0&#125;','&#123;1&#125;');insert into img_and_key_relation(keyword_id,image_id) values('&#123;2&#125;','&#123;3&#125;');", keywordDic[keyword[i]], keyword[i], keywordDic[keyword[i]], numOfImage); &#125; else &#123; int keyword_id = keywordDic[keyword[i]]; insertKeyAndR = insertKeyAndR + string.Format(@"insert into img_and_key_relation(keyword_id,image_id) values('&#123;0&#125;','&#123;1&#125;');", keyword_id, numOfImage); &#125; &#125; &#125; sqlCommond = insertImageCommond + insertKeyAndR; SQLStringList.Add(sqlCommond); break; &#125; &#125; return SQLStringList;&#125; 为了将关键字是空格的图像解析出去，所以使用了两种方式，一般有空格的图像信息的键值长度为1，但是键值为1的又不一定是空格（有点啰嗦意思理解就好）所以将解析方式设为两种，键值长度为1与&gt;1两种。然后判断键值是否为空格，不是空格的话将图像长度+1，数据库中图像表的键值与图片长度（相当于图片的index）相关联。因为一个图像不一定有一个关键字，所以图像的插入语句与关键字与关系表的插入语句分开统计。获得每个图片关键字的长度，将每一个图片的关键字使用Sqlit(&#39; &#39;)解析到一个字符串数组中，遍历字符串判断关键字是否存在在字典中，不存在的话将该关键字插入到关键字表中，存在的话直接在关键字字典中查找该关键字的键值，将图像的键值与该关键字的键值插入到关系表中。最后将该图片的所有插入语句赋值给sqlCommond，加入到指令列表SQLStringList中，解析完后返回列表。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程共享（c语言实现）]]></title>
      <url>%2F2016%2F11%2F26%2Fc%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%2F</url>
      <content type="text"><![CDATA[引言工作需要修改一个bug，bug原因是共享内存时出现内存读写错误，导致信息无法显示，在此之前并没有接触过进程间通信的问题，所以学习了一下相关的知识，以下是网上的步骤讲解，做个笔记，方便以后复习。 c进程共享的实现同机进程共享内存 步骤1.服务器端进程调用内存映射函数CreateFileMapping创建一个有名字标识的共享内存;CreateFileMapping原型如下：12345678HANDLE CreateFileMapping (HANDLE hFile, // 映射文件的句柄，若设为0xFFFFFFFF(即：INVALID_HANDLE_VALUE)则创建一个进程间共享的对象LPSECURITY_ATTRIBUTES lpFileMappingAttributes, //安全属性DWORD flProtect, //保护方式DWORD dwMaximumSizeHigh, //对象的大小DWORD dwMaximumSizeLow, LPCTSTR lpName // 映射文件名，即共享内存的名称); 与虚拟内存类似，保护方式参数可以是PAGE_READONLY或是PAGE_READWRITE。如果多进程都对同一共享内存进行写访问，则必须保持相互间同步。映射文件还可以PAGE_WRITECOPY标志，可以保证其原始数据不会遭到破坏，同时允许其他进程在必要时自由的操作数据的拷贝。 创建一个名为“zzj”的长度为4096字节的有名映射文件：HANDLE m_hMapFile=CreateFileMapping((HANDLE)0xFFFFFFFF,NULL,PAGE_READWRITE,0,0x1000,&quot; zzj&quot;); 2.创建文件映射对象后，服务器端进程调用MapViewOfFile函数映射到本进程的地址空间内映射缓存区视图void* m_pBaseMapFile=MapViewOfFile(m_hMapFile,FILE_MAP_READ|FILE_MAP_WRITE,0,0,0); 3.客户端进程访问共享内存对象，需要通过内存对象名调用OpenFileMapping函数，获得共享内存的句柄HANDLE m_hMapFile =OpenFileMapping(FILE_MAP_WRITE,FALSE,&quot; zzj&quot;); 4.如果客户端进程获得共享内存对象的句柄成功，则调用MapViewOfFile函数来映射对象视图。用户用该对象视图来进行数据读写操作，达到数据通信的目的。映射缓存区视图void* m_pBaseMapFile=MapViewOfFile(m_hMapFile,FILE_MAP_READ|FILE_MAP_WRITE,0,0,0); 5.当用户进程结束共享内存后，调用UnmapViewOfIFile函数以取消其地址空间内的视图12345if (m_pBaseMapFile) &#123; UnmapViewOfFile(m_pBaseMapFile); SharedMapView=NULL; &#125; 使用文件映射实现共享内存FileMapping用于将存在于磁盘的文件放进一个进程的虚拟地址空间，并在该进程的虚拟地址空间中产生一个区域用于“存放”该文件，这个空间就叫做File View（存放在进程的虚拟内存中），系统并同时产生一个File Mapping Object（存放于物理内存中）用于维持这种映射关系，这样当多个进程需要读写那个文件的数据时，它们的File View其实对应的都是同一个File Mapping Object，这样做可节省内存和保持数据的同步性，并达到数据共享的目的。 当然在一个应用向文件中写入数据时，其它进程不应该去读取这个正在写入的数据。这就需要进行一些同步的操作。下边来看一下具体的API。 CreateFileMaping的用法：12345678HANDLE CreateFileMapping( //返回FileMapping Object的句柄HANDLE hFile, //想要产生映射的文件的句柄LPSECURITY_ATTRIBUTES lpAttributes, //安全属性（只对NT和2000生效）DWORD flProtect, //保护标致DWORD dwMaximumSizeHigh, //在DWORD的高位中存放File Mapping Object的大小DWORD dwMaximumSizeLow, //在DWORD的低位中存放File Mapping Object的大小（通常这两个参数有一个为0）LPCTSTR lpName //File Mapping Object的名称。); 1)物理文件句柄 任何可以获得的物理文件句柄，如果你需要创建一个物理文件无关的内存映射也无妨，将它设置成为 0xFFFFFFFF(INVALID_HANDLE_VALUE)就可以了. 如果需要和物理文件关联，要确保你的物理文件创建的时候的访问模式和”保护设置”匹配，比如:物理文件只读，内存映射需要读写就会发生错误。推荐你的物理文件使用独占方式创建。 如果使用 INVALID_HANDLE_VALUE，也需要设置需要申请的内存空间的大小，无论物理文件句柄参数是否有效,这样 CreateFileMapping就可以创建一个和物理文件大小无关的内存空间给你,甚至超过实际文件大小，如果你的物理文件有效，而大小参数为0，则返回给你的是一个和物理文件大小一样的内存空间地址范围。返回给你的文件映射地址空间是可以通过复制，集成或者命名得到，初始内容为0。 2)保护设置 就是安全设置,不过一般设置NULL就可以了,使用默认的安全配置. 在win2k下如果需要进行限制,这是针对那些将内存文件映射共享给整个网络上面的应用进程使用是,可以考虑进行限制. 3)高位文件大小 32位地址空间,设置为0。 4) 共享内存名称 命名可以包含 “Global”或者 “Local” 前缀在全局或者会话名空间初级文件映射.其他部分可以包含任何除了()以外的字符,可以参考 Kernel Object Name Spaces. 5)调用CreateFileMapping的时候GetLastError的对应错误 ERROR_FILE_INVALID 如果企图创建一个零长度的文件映射,应有此报ERROR_INVALID_HANDLE 如果发现你的命名内存空间和现有的内存映射,互斥量,信号量,临界区同名就麻烦了ERROR_ALREADY_EXISTS 表示内存空间命名已经存在 使用函数CreateFileMapping创建一个想共享的文件数据句柄，然后使用MapViewOfFile来获取共享的内存地址，然后使用OpenFileMapping函数在另一个进程里打开共享文件的名称，这样就可以实现不同的进程共享数据。 代码示例：这个程序包括一个客户端和一个服务端，服务端创建共享内存，客户端打开共享内存，两者通过两个事件互斥访问共享内存，实现一个小功能，就是服务端进程从控制台读入数据发送给客户端进程。 服务端：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include "stdafx.h" #include &lt;Windows.h&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; HANDLE hMutex = NULL; HANDLE hFileMapping = NULL; LPVOID lpShareMemory = NULL; HANDLE hServerWriteOver = NULL; HANDLE hClientReadOver = NULL; //create share memory hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 1024*1024, L"ShareMemoryTest"); if (NULL == hFileMapping) &#123; cout &lt;&lt; "CreateFileMapping fail:" &lt;&lt; GetLastError() &lt;&lt; endl; goto SERVER_SHARE_MEMORY_END; &#125; lpShareMemory = MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, //memory start address 0); //all memory space if (NULL == lpShareMemory) &#123; cout &lt;&lt; "MapViewOfFile" &lt;&lt; GetLastError() &lt;&lt; endl; goto SERVER_SHARE_MEMORY_END; &#125; hMutex = CreateMutex(NULL, FALSE, L"SM_Mutex"); if (NULL == hMutex || ERROR_ALREADY_EXISTS == GetLastError()) &#123; cout &lt;&lt; "CreateMutex" &lt;&lt; GetLastError() &lt;&lt; endl; goto SERVER_SHARE_MEMORY_END; &#125;//多个线程互斥访问 //send data hServerWriteOver = CreateEvent(NULL, TRUE, FALSE, L"ServerWriteOver"); hClientReadOver = CreateEvent(NULL, TRUE, FALSE, L"ClientReadOver"); if (NULL == hServerWriteOver || NULL == hClientReadOver) &#123; cout &lt;&lt; "CreateEvent" &lt;&lt; GetLastError() &lt;&lt; endl; goto SERVER_SHARE_MEMORY_END; &#125; char p = 0; char* q = (char*)lpShareMemory; do &#123; p = getchar(); if (WaitForSingleObject(hClientReadOver, 5*1000) != WAIT_OBJECT_0) goto SERVER_SHARE_MEMORY_END; q[0] = p; if (!ResetEvent(hClientReadOver)) goto SERVER_SHARE_MEMORY_END;//把指定的事件对象设置为无信号状态 if (!SetEvent(hServerWriteOver)) goto SERVER_SHARE_MEMORY_END;//把指定的事件对象设置为有信号状态 &#125; while (p != '\n'); SERVER_SHARE_MEMORY_END: //release share memory if (NULL != hServerWriteOver) CloseHandle(hServerWriteOver); if (NULL != hClientReadOver) CloseHandle(hClientReadOver); if (NULL != lpShareMemory) UnmapViewOfFile(lpShareMemory); if (NULL != hFileMapping) CloseHandle(hFileMapping); if (NULL != hMutex) ReleaseMutex(hMutex); return 0; &#125; 客户端：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h" #include &lt;Windows.h&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; HANDLE hMutex = NULL; HANDLE hFileMapping = NULL; LPVOID lpShareMemory = NULL; HANDLE hServerWriteOver = NULL; HANDLE hClientReadOver = NULL; hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, L"SM_Mutex"); if (NULL == hMutex) &#123; if (ERROR_FILE_NOT_FOUND == GetLastError()) &#123; cout &lt;&lt; "OpenMutex fail: file not found!" &lt;&lt; endl; goto CLIENT_SHARE_MEMORY_END; &#125; else &#123; cout &lt;&lt; "OpenMutex fail:" &lt;&lt; GetLastError() &lt;&lt; endl; goto CLIENT_SHARE_MEMORY_END; &#125; &#125; if (WaitForSingleObject(hMutex, 5000) != WAIT_OBJECT_0)//hMutex 一旦互斥对象处于有信号状态，则该函数返回 &#123; DWORD dwErr = GetLastError(); goto CLIENT_SHARE_MEMORY_END; &#125; //open share memory hFileMapping = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, L"ShareMemoryTest"); if (NULL == hFileMapping) &#123; cout &lt;&lt; "OpenFileMapping" &lt;&lt; GetLastError() &lt;&lt; endl; goto CLIENT_SHARE_MEMORY_END; &#125; lpShareMemory = MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0); if (NULL == lpShareMemory) &#123; cout &lt;&lt; "MapViewOfFile" &lt;&lt; GetLastError() &lt;&lt; endl; goto CLIENT_SHARE_MEMORY_END; &#125; //read and write data hServerWriteOver = CreateEvent(NULL, TRUE, FALSE, L"ServerWriteOver"); hClientReadOver = CreateEvent(NULL, TRUE, FALSE, L"ClientReadOver"); if (NULL == hServerWriteOver || NULL == hClientReadOver) &#123; cout &lt;&lt; "CreateEvent" &lt;&lt; GetLastError() &lt;&lt; endl; goto CLIENT_SHARE_MEMORY_END; &#125; char p = 0; char* q = (char*)lpShareMemory; do &#123; if (!SetEvent(hClientReadOver)) goto CLIENT_SHARE_MEMORY_END; if (WaitForSingleObject(hServerWriteOver, INFINITE) != WAIT_OBJECT_0) goto CLIENT_SHARE_MEMORY_END; p = q[0]; putchar(p); if (!ResetEvent(hServerWriteOver)) goto CLIENT_SHARE_MEMORY_END; &#125; while (p != '\n'); CLIENT_SHARE_MEMORY_END: //release share memory if (NULL != hServerWriteOver) CloseHandle(hServerWriteOver); if (NULL != hClientReadOver) CloseHandle(hClientReadOver); if (NULL != lpShareMemory) UnmapViewOfFile(lpShareMemory); if (NULL != hFileMapping) CloseHandle(hFileMapping); if (NULL != hMutex) ReleaseMutex(hMutex); return 0; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WndProc窗口过程]]></title>
      <url>%2F2016%2F11%2F26%2Fwindows%E7%AA%97%E5%8F%A3%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[应用程序通过GetMessage方法最终将消息提交到窗口过程 WndProc（指向一个用用程序定义的窗口过程的指针） 回调函数每个窗口会有一个称为窗口过程的回调函数(WndProc)，带有四个参数，分别为： 窗口句柄(Window Handle) HWND,消息ID(Message ID) UINT,和两个消息参数(wParam, lParam)WPARAM、LPARAM,WndProc的第一个参数hWnd就是当前接收消息的窗口句柄，第二个参数就是被传送过来的消息，第三、第四个参数都是附加在消息上的数据，这和MSG结构体是一样的。 窗口过程 1234567LRESULT CALLBACK WndProc( //WndProc名称可自由定义 HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)；pOldProc:Pointer; //子类化前的窗口程序（WndProc）指针]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内存共享（c#实现）]]></title>
      <url>%2F2016%2F11%2F26%2F%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%2F</url>
      <content type="text"><![CDATA[引言工作需要修改一个bug，bug原因是共享内存时出现内存读写错误，导致信息无法显示，在此之前并没有接触过进程间通信的问题，所以学习了一下相关的知识，以下是网上的步骤讲解，做个笔记，方便以后复习。 c#共享内存共享内存为进程通信的一种方式，多个进程可以将共享的内存地址映射到自己的地址范围，从而实现消息的传送，完成通信。 c#中完成共享内存方式在c#中使用费托管代码（即操作系统执行的代码属于操作系统内核）,需要使用DllImport（&quot;user32.dll&quot;），完整的调用如下图：1234567891011121314151617181920[DllImport("user32.dll", CharSet = CharSet.Auto)] public static extern IntPtr SendMessage(IntPtr hWnd, int Msg, int wParam, IntPtr lParam); [DllImport("Kernel32.dll", CharSet = CharSet.Auto)] public static extern IntPtr CreateFileMapping(int hFile, IntPtr lpAttributes, uint flProtect, uint dwMaxSizeHi, uint dwMaxSizeLow, string lpName); [DllImport("Kernel32.dll", CharSet = CharSet.Auto)] public static extern IntPtr OpenFileMapping(int dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, string lpName); [DllImport("Kernel32.dll", CharSet = CharSet.Auto)] public static extern IntPtr MapViewOfFile(IntPtr hFileMapping, uint dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, uint dwNumberOfBytesToMap); [DllImport("Kernel32.dll", CharSet = CharSet.Auto)] public static extern bool UnmapViewOfFile(IntPtr pvBaseAddress); [DllImport("Kernel32.dll", CharSet = CharSet.Auto)] public static extern bool CloseHandle(IntPtr handle); [DllImport("kernel32", EntryPoint = "GetLastError")] public static extern int GetLastError(); 使用用DllImport（&quot;user32.dll&quot;）调用Win32的API,其中的属性定义CharSet：控制名称重整以及将字符串参数封送到函数的方式，默认为ASCALL，EntryPoint表示入口地址，也就是将函数重命名。 以下是写共享内存的代码：代码以及解析转载自CSDN的richerg85 创建共享内存的过程： 创建共享内存文件(CreateFileMapping)—》映射文件视图到调用进程的地址空间（MapViewOfFile）—》写数据到共享内存(Marshal.StructureToPtr)—-》发送消息通知需要读共享内存的窗口（PostMessage） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// &lt;summary&gt; /// 写共享内存 /// &lt;/summary&gt; /// &lt;param name="structSize"&gt;需要映射的文件的字节数量&lt;/param&gt; /// &lt;param name="obj"&gt;映射对象（简单类型、结构体等）&lt;/param&gt; /// &lt;param name="fileName"&gt;文件映射对象的名称&lt;/param&gt; /// &lt;param name="windowName"&gt;发送消息的窗口句柄&lt;/param&gt; /// &lt;param name="Msg"&gt;发送消息&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static int WriteToMemory(uint structSize, Object obj, string fileName, string windowName, uint Msg) &#123; IntPtr hShareMemoryHandle = IntPtr.Zero; IntPtr hVoid = IntPtr.Zero; //判断参数的合法性 if (structSize &gt; 0 &amp;&amp; fileName.Length &gt; 0) &#123; hShareMemoryHandle = CreateFileMapping(INVALID_HANDLE_VALUE, IntPtr.Zero, (uint)PAGE_READWRITE, 0, (uint)structSize, fileName); if (hShareMemoryHandle == IntPtr.Zero) &#123; //创建共享内存失败，记log MessageBox.Show("创建共享内存失败"+publicInfo.GetLastError().ToString()); return -2; &#125; else &#123; if (ERROR_ALREADY_EXISTS == GetLastError()) &#123; //共享内存已经存在，记log MessageBox.Show("共享内存已经存在"); return -3; &#125; &#125; hVoid = MapViewOfFile(hShareMemoryHandle, FILE_MAP_WRITE, 0, 0, structSize); if (hVoid == IntPtr.Zero) &#123; CloseHandle(hShareMemoryHandle); //文件映射失败，记log MessageBox.Show("文件映射失败"); return -4; &#125; Marshal.StructureToPtr(obj, hVoid, false); //发送消息，通知接收 IntPtr handle = FindWindow(null, windowName.Trim()); if (handle == IntPtr.Zero) &#123; //查找窗口失败，记log MessageBox.Show("查找窗口失败"); return -5; &#125; else &#123; if (PostMessage(handle, (uint)Msg, 0, 0)) &#123; //发送消息成功 //MessageBox.Show("写共享内存，通知发送消息成功"); &#125; &#125; &#125; else &#123; //参数不合法，记log MessageBox.Show("共享内存已经存在"); return -1; &#125; return 0; &#125; 读共享内存的代码： 读共享内存，上边代码是一种方式，这里是传入一个Type类型，这样就确保可以传入任何类型。当读到共享内存的数据时，采用 public static object PtrToStructure(IntPtr ptr, Type structureType); 函数，把非托管指针（共享内存获得的指针）转换为需要转换的Type类型的对象。如果需要的话，可以通过显示类型转换转换为需要的类型（例子继续看）。123456789101112131415161718192021222324252627282930313233343536373839404142/// &lt;summary&gt; /// 读共享内存 /// &lt;/summary&gt; /// &lt;param name="structSize"&gt;需要映射的文件的字节数量&lt;/param&gt; /// &lt;param name="type"&gt;类型&lt;/param&gt; /// &lt;param name="fileName"&gt;文件映射对象的名称&lt;/param&gt; /// &lt;returns&gt;返回读到的映射对象&lt;/returns&gt; public static Object ReadFromMemory(uint structSize, Type type, string fileName) &#123; IntPtr hMappingHandle = IntPtr.Zero; IntPtr hVoid = IntPtr.Zero; hMappingHandle = OpenFileMapping((uint)FILE_MAP_READ, false, fileName); if (hMappingHandle == IntPtr.Zero) &#123; //打开共享内存失败，记log MessageBox.Show("打开共享内存失败:" + publicInfo.GetLastError().ToString()); return null; &#125; hVoid = MapViewOfFile(hMappingHandle, FILE_MAP_READ, 0, 0, structSize); if (hVoid == IntPtr.Zero) &#123; //文件映射失败，记log MessageBox.Show("文件映射失败——读共享内存"); return null; &#125; Object obj = Marshal.PtrToStructure(hVoid, type); if (hVoid != IntPtr.Zero) &#123; UnmapViewOfFile(hVoid); hVoid = IntPtr.Zero; &#125; if (hMappingHandle != IntPtr.Zero) &#123; CloseHandle(hMappingHandle); hMappingHandle = IntPtr.Zero; &#125; return obj; &#125; 此代码和第一个读共享内存不同的是，采用byte[]读需要的共享内存。使用托管类中的Copy来转换指针。 byte[] bytes = new byte[structSize]; arshal.Copy(hVoid, bytes, 0, bytes.Length); 注：passiveInfo是NotifyInfo结构体对象。 写共享内存： int iRet = publicInfo.WriteToMemory((uint)Marshal.SizeOf(passiveInfo),(Object)passiveInfo, &quot;memName&quot;,&quot;FormMsg&quot;,(uint)publicInfo.WM_NOTIFY); 第一种情况调用：passiveInfo = (NotifyPassiveInfo)publicInfo.ReadFromMemory((uint)Marshal.SizeOf(passiveInfo), typeof(NotifyPassiveInfo), publicInfo.SN_PASSIVEINFO); 第二种情况调用：byte[] bytes = publicInfo.ReadFromMemory((uint)Marshal.SizeOf(passiveInfo), &quot;memName&quot;); passiveInfo = (NotifyInfo)BytesToStuct(bytes, typeof(NotifyInfo));代码以及解析转载自]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GDT与LDT]]></title>
      <url>%2F2016%2F11%2F26%2F%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[引言全局描述符表与局部描述符表过去虽然看过，但是印象不深很深，后来看了《自己动手实现一个操作系统》，提到实模式到保护模式转换时，改短代码初始时候只能看懂几句，无法通透，所以过来补充点基础知识，关于本书的笔记往后补上。 LDT属于程序，GDT属于系统，同一台计算机上的所有程序共享一个GDT。LDT描述局部于每个程序的段，包括其代码、数据、堆栈等。GDT描述系统段，包括操作系统本身。 GDT整个系统中只有GDT（一个处理器对应一个），可以存放在内存的任何位置，那么如何获得GDT的入口地址呢？ Intel使用一个48位的寄存器GDTR存储GDT的入口地址。使用LGDT xxx将GDT的入口地址装入GDTR，之后CPU根据GSTR的内容访问GDT表，相应的又LDTR，与GDTR相同的功能，只是它存放的LDT的入口地址。 段选择子(Selector)GDTR访问全局描述符表是通过“段选择子”（实模式下的段寄存器16bit）完成，为了访问一个段，需要将这个段的选择子装入6个段寄存器中的一个。在运行过程中，cs寄存器保存代码段的选择子，ds寄存器保存数据段的选择子，每个选择子16bit。如图所示，选择子的第2位T指出访问的是全局描述符表（0）还是局部描述符表（1），3~15位索引是LDT或GDT表的表项编号，指明在表中的位置。找到相应的描述符后使用sel:offset转换为线性地址。所以描述符表最大能够存储2^13=8KB个描述符。第0位RPL表示选择子的特权级，共有四个特权级(0级，1级，2级，3级)。在任务重每一个段都有一个特定的基本，每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较（数字越小级别越高）。系统规定，CPU只能访问同一个特权级或者级别较低特权级的段。GDT与LDT都是保护模式中的，之前不明白实模式与保护模式的区别，如何保护，系统级别与特权级别的区别在哪里，到这里稍微有点明白。在保护模式中通过描述符表，选择子加入了特权级别的检验一下是全局描述符表的数据结构：12345struct SEGMENT_DESCRIPTOR&#123;short limit_low,base_low;/*段上限的低16位和段基址的低16位*/char base_mid,access_right;/*访问权限*/char limit_high,base_hight;/*段上限的高8位和基址的高8位*/&#125;; LDT局部描述符表可以有若干张，每个任务可以有一张。我们可以这样理解GDT和LDT：GDT为一级描述符表，LDT为二级描述符表。如图LDT和GDT从本质上说是相同的，只是LDT嵌套在GDT之中。LDTR记录局部描述符表的起始位置，与GDTR不同LDTR的内容是一个段选择子。由于LDT本身同样是一段内存，也是一个段，所以它也有个描述符描述它，这个描述符就存储在GDT中，对应这个表述符也会有一个选择子，LDTR装载的就是这样一个选择子。LDTR可以在程序中随时改变，通过使用lldt指令。如上图，如果装载的是Selector 2则LDTR指向的是表LDT2。举个例子：如果我们想在表LDT2中选择第三个描述符所描述的段的地址12345678h。 首先需要装载LDTR使它指向LDT2 使用指令lldt将Select2装载到LDTR 通过逻辑地址（SEL:OFFSET）访问时SEL的index=3代表选择第三个描述符；TI=1代表选择子是在LDT选择，此时LDTR指向的是LDT2,所以是在LDT2中选择，此时的SEL值为1Ch(二进制为11 1 00b)。OFFSET=12345678h。逻辑地址为1C:12345678h 由SEL选择出描述符，由描述符中的基址（Base）加上OFFSET可得到线性地址，例如基址是11111111h，则线性地址=11111111h+12345678h=23456789h 此时若再想访问LDT1中的第三个描述符，只要使用lldt指令将选择子Selector 1装入再执行2、3两步就可以了（因为此时LDTR又指向了LDT1）由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问。P,present位,1表示所描述的段存在(有效),为0表示所描述的段无效,使用该描述符会引起异常DPL,Descriptor privilege,描述符特权级别,说明所描述段的特权级别DT,描述符类型位,1说明当前描述符为存储段描述符,0为系统描述符或门描述符.TYPE:位0:A(accessed)位,表明描述符是否已被访问;把选择子装入段寄存器时,该位被标记为1位3:E(EXECUTABLE?)位,0说明所描述段为数据段;1为可执行段(代码段)当为数据段时,位1为W位,说明该数据段是否可写(0只读,1可写)位2为ED位,说明该段的扩展方向(0向高位扩展,1向低位扩展)当为可执行段是,位1为R位,说明该执行段是否可读(0只执行,1可读)位2为C位,0说明该段不是一致码段(普通代码段),1为一致码段G为粒度位,0说明LIMIT粒度为字节,1为4K字节.D位:1.在可执行段中,D为1,表示使用32位地址,32/8位操作数;为0表示使用16位地址,16/8位操作数2.在由SS寻址的段描述符(堆栈段?)中,D为1表示隐含操作(如PUSH/POP)使用ESP为堆栈指针, 为0使用SP(隐含操作:未明确定义段属性类型USE16/USE32?66H,67H?)3.在向低扩展的存储段中,D为1,表示段的上限为4G;为0上限为64K存储段描述符的结构表示:分段管理可以把虚拟地址转换成线性地址，而分页管理可以进一步将线性地址转换成物理地址。当CR0中的PG位置1时，启动分页管理功能，为0时，这禁止启动分页管理功能，并且把线性地址作物理地址使用。 虚拟地址转为线性地址： 线性地址= 段基指 + 偏移地址 32位线性地址转为物理地址：32位分为:页目录索引：占最高10位，指示页目录表中第几个页表描述符页表索引：占12位到21位，也是10位。指示这页表中第几个页描述符页描述符：线性地址的低12位为页内偏移量。 具体描述转载自csdn]]></content>
    </entry>

    
  
  
</search>
